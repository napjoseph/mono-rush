---
title: 'Create a 3D Contribution Chart Using React Three Fiber'
publishedDate: '2023-04-02T03:27:00Z'
tags:
  - '3D'
  - 'Data Visualization'
  - 'React Three Fiber'
  - 'React'
  - 'The Wandering Inn'
  - 'Three.js'
  - 'TypeScript'
---

In this blog post, we will create a 3D visualization of our timeseries data using [React Three Fiber](https://github.com/pmndrs/react-three-fiber), a React renderer for [Three.js](https://threejs.org/). This is inspired by [GitHub Skyline](https://skyline.github.com/), a web application that creates a 3D visualization of a user's GitHub contributions.

![Project Titan](/img/posts/3d-bar-charts/titan.png)

> **NOTE**: You can find the live version at [The Wandering Inndex](https://titan.inndex.omg.lol/) and the full source code on [the wandering-inndex/titan repository](https://github.com/wandering-inndex/titan).

This is rather long, so here's a table of contents:

- [Step 1: Project Setup](#step-1-project-setup)
  - [Prerequisites](#prerequisites)
  - [Create a new Next.js project](#create-a-new-nextjs-project)
  - [Install Additional Project Dependencies](#install-additional-project-dependencies)
  - [Clean up the Home Page](#clean-up-the-home-page)
- [Step 2: Preparing our Data](#step-2-preparing-our-data)
  - [Creating the Type Definitions](#creating-the-type-definitions)
  - [Convert the Chapter data to a mapping of dates to values](#convert-the-chapter-data-to-a-mapping-of-dates-to-values)
  - [Show the parsed Chapter data on the page](#show-the-parsed-chapter-data-on-the-page)
- [Step 3: Creating the Time-series Data](#step-3-creating-the-time-series-data)
  - [Defining the Time-series Data Types](#defining-the-time-series-data-types)
  - [Gregorian Calendar vs ISO 8601 Calendar](#gregorian-calendar-vs-iso-8601-calendar)
  - [Modified Version](#modified-version)
  - [Using date-fns](#using-date-fns)
  - [Converting the ValuesPerDay mapping to our desired data structure](#converting-the-valuesperday-mapping-to-our-desired-data-structure)
- [Step 4: Show the data in a 2D Grid](#step-4-show-the-data-in-a-2d-grid)
- [Step 5: Show the Data in a 3D Grid](#step-5-show-the-data-in-a-3d-grid)
- [Step 6: Adding a helper GUI to customize the chart](#step-6-adding-a-helper-gui-to-customize-the-chart)
- [Conclusion](#conclusion)

---

## Step 1: Project Setup

In this step, we will be creating a new project using [Create T3 App](https://create.t3.gg/). If you already have a React project set up, just install the [additional dependencies listed below](#install-additional-project-dependencies) and skip to the [next step](#step-2-preparing-our-data).

### Prerequisites

Install a version manager for [Node.js](https://nodejs.org/en) for your operating system:

- [Node Version Manager](https://github.com/nvm-sh/nvm) (Linux/macOS)
- [NVM for Windows](https://github.com/coreybutler/nvm-windows) (Windows)

After installing `nvm`, install the latest LTS version of [Node.js](https://nodejs.org/en) by running:

```bash
# Linux/macOS
$ nvm install --lts

# Windows
$ nvm install lts
```

Once that's done, we shall install [pnpm](https://pnpm.io/), an alternative to [npm](https://www.npmjs.com/) that is faster and uses less disk space. To install `pnpm`, run:

```bash
$ npm install -g pnpm
```

### Create a new Next.js project

For this project, we will use [Create T3 App](https://create.t3.gg/) to bootstrap our project. Create T3 App is a CLI tool that helps you create a new project with a pre-configured setup for [Next.js](https://nextjs.org/), [TypeScript](https://www.typescriptlang.org/), and [Tailwind CSS](https://tailwindcss.com/).

To create a new T3 project, run:

```bash
$ pnpm create t3-app@latest
#     ___ ___ ___   __ _____ ___   _____ ____    __   ___ ___
#    / __| _ \ __| /  \_   _| __| |_   _|__ /   /  \ | _ \ _ \
#   | (__|   / _| / /\ \| | | _|    | |  |_ \  / /\ \|  _/  _/
#    \___|_|_\___|_/¯¯\_\_| |___|   |_| |___/ /_/¯¯\_\_| |_|
# ? What will your project be called? (my-t3-app) titan
# ? Will you be using JavaScript or TypeScript? TypeScript
# ? Which packages would you like to enable? tailwind
# ? Initialize a new git repository? (Y/n) Yes
# ? Would you like us to run pnpm install? (Y/n) Yes
# ? What import alias would you like configured? ~/
#
# ✔ titan scaffolded successfully!
```

Feel free to select any name you'd like for your project. However, for the purpose of this guide, we'll go with `titan`, inspired by a character found in [The Wandering Inn](https://wanderinginn.com/), one of the longest pieces of fiction written in English. The [author](https://www.patreon.com/pirateaba) has been writing consistently since 2016, and we'll utilize their writing data for our visualization.

### Install Additional Project Dependencies

After the project is created, change into the project directory:

```bash
$ cd titan
```

Install additional dependencies for our project:

```bash
$ pnpm add three @types/three @react-three/fiber @react-three/drei leva date-fns yaml
```

- `three` is a JavaScript 3D library that we will use to create our 3D visualization.
- `@types/three` is the TypeScript type definitions for `three`.
- `@react-three/fiber` is a React renderer for `three`.
- `@react-three/drei` is a collection of React components for `three`.
- `leva` is a UI library that we will use to create controls for our visualization.
- `date-fns` is a date utility library that we will use to parse and format dates.
- `yaml` is a [YAML](https://yaml.org/) parser that we will use to parse our data source.

### Clean up the Home Page

Open the project in your favorite code editor and delete the contents of `src/pages/index.tsx`. Replace it with the following code:

```tsx filename=src/pages/index.tsx
import type { NextPage } from 'next';
import Head from 'next/head';

const Home: NextPage = () => {
  return (
    <>
      <Head>
        <title>Titan</title>
        <meta name="description" content="Visualize contribution charts in 3D" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className="h-screen w-screen p-1">
        <nav className="absolute left-1/2 z-10 mx-auto my-4 -translate-x-1/2 text-center text-4xl font-bold">
          Titan
        </nav>
      </main>
    </>
  );
};

export default Home;
```

Add a style to your `body` tag by updating `src/styles/globals.css`:

```css filename=src/styles/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply bg-gray-100;
  }
}
```

Afterwards, you can start the development server by running:

```bash
$ pnpm dev
```

It should show an empty page with our project name at the top.

![Empty Page](/img/posts/3d-bar-charts/step-01-empty-page.png)

## Step 2: Preparing our Data

For this project, we will be fetching data from [The Wandering Inndex](https://inndex.omg.lol/), a community-driven project that aims to collect data about [The Wandering Inn](https://wanderinginn.com/) and make it available for the public. The raw data for the published chapters is available in [YAML](https://yaml.org/) format, and we will be using the [yaml](https://www.npmjs.com/package/yaml) package to parse the data.

### Creating the Type Definitions

In [TypeScript](https://www.typescriptlang.org/), [type declarations](https://www.typescriptlang.org/docs/handbook/2/type-declarations.html) are used to define the structure of objects, interfaces, classes, and functions. It provides clarity and documentation to the codebase, making it easier for developers to understand and maintain the project.

To get started, let's declare the type definitions that we will use in our application. Luckily for us, the data that we will be using already has [type definitions available](https://github.com/wandering-inndex/seed-data/blob/main/types/media.ts). We will be using the `Chapter` interface, which represents the individual chapter data. We will only be using a subset of the available fields from the full type definitions, so let's create a new file at `src/types/chapters.ts` and add the following code:

```ts filename=src/types/chapters.ts
/** Minimal interface that represents the individual Chapter data. */
export interface Chapter {
  /** Unique ID for the chapter. */
  id: string;
  /** Flags for the chapter. */
  meta: {
    /** If true, then it will be shown in the table of contents. */
    show: boolean;
  };
  /** Specifies that a chapter is part of a bigger collection. */
  partOf: {
    /** Part of a Web Novel Volume. */
    webNovel?: {
      /** The volume this is collected under. */
      ref: number | null;
      /**
       * The timestamp when this chapter is originally published. This can be
       * found via the `meta[property='article:published_time']` selector.
       */
      published: string | null;
      /**
       * Total words based on https://wordcounter.net/. Without the title,
       * author's notes, artworks, etc.
       */
      totalWords: number | null;
    };
  };
}
```

We only want to show the chapters that are marked as to be shown in the table of contents (`meta.show === true`) and is part of a Web Novel Volume (`partOf.webNovel.ref > 0`). We will also be using the `partOf.webNovel.published` field to determine the date that the chapter was published and the `partOf.webNovel.totalWords` field to determine the number of words for that chapter.

We should also create the type definitions for our Time-related data. Create `src/types/calendar.ts` and add the following:

```ts filename=src/types/calendar.ts
// TODO: Add type definition for `CalendarWeekData`.
// TODO: Add type definition for `CalendarYearData`.
// TODO: Add type definition for `CalendarYearsData`.

/**
 * Maps a value per date string.
 * The date string must be in a valid ISO 8601 format.
 *
 * @see https://en.wikipedia.org/wiki/ISO_8601
 *
 * @example
 * const map: ValuesPerDay = new Map<string, number>([
 *  ["2021-01-01", 1000],
 *  ["2021-01-02", 2000],
 *  ["2021-01-03", 3000],
 * ]);
 */
export type ValuesPerDay = Map<string, number>;
```

Our goal for this step is to convert the `Chapter` data into a mapping of word counts by date (`ValuesPerDay`).

Afterwards, create a `src/types/index.ts` file and add the following code:

```ts filename=src/types/index.ts
export * from './calendar';
export * from './chapters';
```

This will allow us to import all of our types from a single location (e.g. `import { ValuesPerDay } from "~/types/";`).

### Convert the Chapter data to a mapping of dates to values

Let's create a `src/utils/chapters.ts` file and add the following code:

```ts filename=src/utils/chapters.ts
import { isMatch, formatISO, parseISO } from 'date-fns';

import type { Chapter, ValuesPerDay } from '~/types';

/**
 * Checks if a chapter should be included based on the given conditions.
 *
 * @param {Chapter} chapter - The chapter to check.
 * @returns {boolean} - `true` if the chapter should be included, `false`
 * otherwise.
 */
export const shouldIncludeChapter = (chapter: Chapter): boolean => {
  const shouldShow = chapter.meta.show === true;
  const hasValidWebNovelRef = (chapter.partOf.webNovel?.ref ?? 0) > 0;
  const hasValidPublishedDate = isMatch(
    chapter.partOf.webNovel?.published ?? '',
    "yyyy-MM-dd'T'HH:mm:ssXXX"
  );

  return shouldShow && hasValidWebNovelRef && hasValidPublishedDate;
};

/** The return data from the `convertChaptersToMapping` function. */
export interface ConvertChaptersToMappingOutput {
  /** This maps a date string to the number of words written on that day. */
  mapping: ValuesPerDay;
  /** The minimum year in the dataset. */
  minYear: number;
  /** The maximum year in the dataset. */
  maxYear: number;
  /** The minimum value in the dataset. */
  minValue: number;
  /** The maximum value in the dataset. */
  maxValue: number;
}

/**
 * Converts an array of `Chapter` objects to a `ConvertChaptersToMappingOutput`.
 *
 * @param {Chapter[]} chapters - The array of `Chapter` objects.
 * @returns {ConvertChaptersToMappingOutput} - The output of the conversion.
 */
export const convertChaptersToMapping = (chapters: Chapter[]): ConvertChaptersToMappingOutput => {
  const mapping: ValuesPerDay = new Map();

  let minYear = Number.POSITIVE_INFINITY;
  let maxYear = Number.NEGATIVE_INFINITY;
  let minValue = Number.POSITIVE_INFINITY;
  let maxValue = Number.NEGATIVE_INFINITY;

  for (const chapter of chapters) {
    if (!shouldIncludeChapter(chapter)) {
      continue;
    }

    const publishedDate = chapter.partOf.webNovel?.published ?? '';
    const totalWords = chapter.partOf.webNovel?.totalWords ?? 0;

    if (publishedDate) {
      const date = parseISO(publishedDate);
      const dateKey = formatISO(date, {
        representation: 'date'
      });

      const existingWordCount = mapping.get(dateKey) ?? 0;
      const newWordCount = existingWordCount + totalWords;
      mapping.set(dateKey, newWordCount);

      const year = date.getFullYear();
      minYear = Math.min(minYear, year);
      maxYear = Math.max(maxYear, year);
      minValue = Math.min(minValue, newWordCount);
      maxValue = Math.max(maxValue, newWordCount);
    }
  }

  return { mapping, minYear, maxYear, minValue, maxValue };
};
```

This file contains a utility function that will help us convert our `Chapter` data into a mapping of dates to word counts. The code is fairly straightforward, but let's go over it in more detail.

It starts by defining a `shouldIncludeChapter` function that will check if a chapter should be included based on the given conditions. This function will return `true` if the chapter should be included, and `false` otherwise. The conditions are as follows:

- `chapter.meta.show` must be `true`.
- `chapter.partOf.webNovel.ref` must be greater than 0.
- `chapter.partOf.webNovel.published` must be a valid date string.

Next, we define a `convertChaptersToMapping` function that will convert an array of `Chapter` objects to a `ConvertChaptersToMappingOutput`. This function will return an object that contains the following properties:

- `mapping`: This maps a date string to the number of words written on that day.
- `minYear`: The minimum year in the dataset.
- `maxYear`: The maximum year in the dataset.
- `minValue`: The minimum value in the dataset.
- `maxValue`: The maximum value in the dataset.

The function will loop through each chapter and check if it should be included. If it should be included, it will add the number of words written on that day to the mapping. It will also update the `minYear`, `maxYear`, `minValue`, and `maxValue` properties as needed.

Like before, create a `src/utils/index.ts` file and add the following code:

```ts filename=src/utils/index.ts
export * from './chapters';
```

### Show the parsed Chapter data on the page

Let's update our `src/pages/index.tsx` page to fetch our `Chapter` data from the source repository. Afterwards, we'll convert the data using `convertChaptersToMapping` and show the relevant data on the page.

```tsx filename=src/pages/index.tsx
import type { NextPage, GetServerSideProps } from 'next';
import Head from 'next/head';

import { parse as parseYaml } from 'yaml';

import { convertChaptersToMapping } from '~/utils';
import type { Chapter } from '~/types';

const URL = `https://raw.githubusercontent.com/wandering-inndex/seed-data/main/data/media/twi-webnovel-chapters.yaml`;

interface HomeProps {
  /** The minimum year in the dataset. */
  minYear: number;
  /** The maximum year in the dataset. */
  maxYear: number;
  /** The minimum value in the dataset. */
  minValue: number;
  /** The maximum value in the dataset. */
  maxValue: number;
}

const Home: NextPage<HomeProps> = ({ minYear, maxYear, minValue, maxValue }) => {
  return (
    <>
      <Head>
        <title>Titan</title>
        <meta name="description" content="Visualize contribution charts in 3D" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className="h-screen w-screen p-1">
        <nav className="absolute left-1/2 z-10 mx-auto my-4 -translate-x-1/2 text-center text-4xl font-bold">
          Titan
        </nav>
        <ul>
          <li>Minimum Year: {minYear}</li>
          <li>Maximum Year: {maxYear}</li>
          <li>Minimum Value: {minValue.toLocaleString('en-US')}</li>
          <li>Maximum Value: {maxValue.toLocaleString('en-US')}</li>
        </ul>
      </main>
    </>
  );
};

export const getServerSideProps: GetServerSideProps<HomeProps> = async () => {
  const res = await fetch(URL);
  const text = await res.text();
  const chapters: Chapter[] = parseYaml(text) as Chapter[];

  const { minYear, maxYear, minValue, maxValue } = convertChaptersToMapping(chapters);

  return {
    props: {
      minYear,
      maxYear,
      minValue,
      maxValue
    }
  };
};

export default Home;
```

[getServerSideProps](https://nextjs.org/docs/basic-features/data-fetching/get-server-side-props) is a special Next.js function that will run on the server before the page is rendered. We are using this function to fetch the YAML data from [our data source](https://raw.githubusercontent.com/wandering-inndex/seed-data/main/data/media/twi-webnovel-chapters.yaml). We will then convert the data to a mapping of dates to values using the `convertChaptersToMapping` function we created earlier. We are then returning the `minYear`, `maxYear`, `minValue`, and `maxValue` properties as props to our `Home` component. We are then showing the values as a simple HTML list.

![With Values](/img/posts/3d-bar-charts/step-02-with-values.png)

## Step 3: Creating the Time-series Data

### Defining the Time-series Data Types

Now, let's go define the data structure that will be used to visualize the data. We'll start by updating the `src/types/calendar.ts` file and adding the following code to the top:

```ts filename=src/types/calendar.ts
/**
 * Represents a tuple of a given type `T` and fixed length `N`.
 *
 * @see https://stackoverflow.com/a/74801694
 */
type Tuple<T, N extends number, R extends T[] = []> = number extends N
  ? T[]
  : R['length'] extends N
  ? R
  : Tuple<T, N, [T, ...R]>;

/**
 * An array that represents values per day of the week.
 *
 * For this project, the first day of the week will be Monday, as per ISO 8601:
 *
 * - INDEX 0: MON
 * - INDEX 1: TUE
 * - INDEX 2: WED
 * - INDEX 3: THU
 * - INDEX 4: FRI
 * - INDEX 5: SAT
 * - INDEX 6: SUN
 *
 * @see https://en.wikipedia.org/wiki/ISO_8601
 *
 * If there are no values for that specific day, it will be 0.
 * If that day is not part of the calendar year, it will be -1.
 *
 * @example
 * const week: CalendarWeekData = [1000, 2000, 3000, 4000, 5000, 6000, 7000];
 * const weekWithoutValues: CalendarYearData = [0, 0, 0, 0, 0, 0, 0];
 * const weekWithDaysNotInYear: CalendarYearData = [-1, -1, -1, -1, -1, -1, -1];
 * const weekMixed: CalendarYearData = [-1, -1, 0, 0, 5000, 0, 7000];
 */
export type CalendarWeekData = Tuple<number, 7>;

/**
 * An array that represents values per week of the year.
 *
 * Most years have 52 weeks, but if the year starts on a Thursday or is a leap
 * year that starts on a Wednesday, that particular year will have 53 weeks.
 *
 * In ISO 8601, if January 1 is on a Monday, Tuesday, Wednesday, or Thursday, it
 * is in week 1. If January 1 is on a Friday, Saturday or Sunday, it is in week
 * 52 or 53 of the previous year (there is no week 0). December 28 will always
 * be in the last week of its year.
 *
 * @see https://en.wikipedia.org/wiki/ISO_8601
 *
 * For this project:
 *
 * - We will *ALWAYS* create a 54-week year.
 * - If a date's month is January and its week number is greater than 50, it
 *   will be changed to week 0.
 * - If a date's month is December and its week number is less than 10, it
 *   will be changed to the number of ISO 8601 weeks in that year + 1. The total
 *   weeks will be coming from to `date-fns`:
 *   {@link https://date-fns.org/docs/getISOWeeksInYear}
 */
export type CalendarYearData = Array<CalendarWeekData>;

/** An array that represents values per year. */
export type CalendarYearsData = Array<CalendarYearData>;

// ...
//
// Definition for `ValuesPerDay`
```

Our goal for this step is to convert the `ValuesPerDay` mapping to an array of `CalendarYearData`. A `CalendarYearData` is just an array of `CalendarWeekData` values, which are just arrays of word counts per week.

To help you visualize this multi-dimensional array, we'll create a 2D grid, where the X-axis represents the week number, the Y-axis represents the day, and the cell value represents the word count.

[![Year Grid](/img/posts/3d-bar-charts/step-03-year-grid.png)](/img/posts/3d-bar-charts/step-03-year-grid.png)

You may have noticed a few things about this grid:

- The week starts on Monday (index 0) and ends on Sunday (index 6).
- There are 54 weeks (indexes 0 to 53) instead of the usual 52 or 53 weeks.

Firstly, it's important to note that the beginning of the week [differs across cultures](https://www.timeanddate.com/date/week-numbers.html), and the number of weeks in a year can vary too. Some years have 52 weeks, others have 53 weeks on leap years. Additionally, since the start of the week can vary, the number of weeks can differ as well. For this project, we will use the [ISO 8601 standard](https://en.wikipedia.org/wiki/ISO_8601) as our basis, with some modifications.

### Gregorian Calendar vs ISO 8601 Calendar

ISO 8601 is a standard that defines a way to represent dates and times. For further reading, check out [Wikipedia: ISO 8601](https://en.wikipedia.org/wiki/ISO_8601), [Wikipedia: ISO week date](https://en.wikipedia.org/wiki/ISO_week_date#Relation_with_the_Gregorian_calendar), and [Tableau: ISO-8601 Week-Based Calendar](https://help.tableau.com/current/pro/desktop/en-us/dates_calendar.htm).

Here are some of the differences between the Gregorian Calendar and the ISO 8601 Calendar:

| Gregorian Calendar                       | ISO 8601 Calendar                                                                                                                      |
| ---------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| Will always start the year on January 1. | Years always start on the first Monday closest to January 1. This means the year may start anywhere between December 29 and January 4. |
| Permits weeks to extend across years.    | Weeks have exactly 7 days and start on a Monday. Each week belongs to single year.                                                     |
| Years can have 365 or 366 days.          | An ISO week-numbering year has 52 or 53 full weeks. That is 364 or 371 days.                                                           |

Below, you can see the difference when transitioning from December 2004 to January 2005. The Gregorian Calendar starts the year on January 1, while the ISO 8601 Calendar starts the year on January 3.

![Different Calendars](/img/posts/3d-bar-charts/step-03-iso-8601-calendar.png)

Calendar applications will usually use the Gregorian calendar, and will have the option to show the ISO 8601 week numbers, as well.

![Combined Calendars](/img/posts/3d-bar-charts/step-03-combined-calendars.png)

### Modified Version

ISO 8601 is a very useful standard, but we need to modify it to fit our requirements:

- Our year will always have 54 weeks (378 days). This ensures that all years have the same number of columns when we show the grids side-by-side.
  - The extra week will be placed at the start, giving it the index of 0.
- The week number will follow the ISO 8601 standard, with the following exceptions:
  - If the date's month is January but the ISO week number is greater than 50, change the week number to 0.
  - If the date's month is December but the ISO week number is less than 10, change the week number to the max ISO 8601 week number plus 1.
- Our weeks will start on Monday. The days will have 0 based indexes, so Monday will be 0 and Sunday will be 6.
- In our data structure, the word counts for each week will be represented as an array of 7 numbers. If the week has unused slots, the values for those days will be represented as negative numbers.

Let's try to visualize this modified calendar:

![Combined and Modified Calendars](/img/posts/3d-bar-charts/step-03-combined-modified-calendars.png)

2004 will end on Week 53, with two unused days at the end (marked as `X` in the chart). 2005 will start on Week 0, with five unused days at the beginning (marked as `X` in the chart). Week 1 will start on January 3. If we continue and fill up our grid for the year 2005 with our dates, we will get:

[![Year 2005 Grid](/img/posts/3d-bar-charts/step-03-year-2005-grid.png)](/img/posts/3d-bar-charts/step-03-year-2005-grid.png)

> **NOTE**: Notice that we have 13 unused days for 2005. Week 0 has 5 at the start, Week 52 has 1 at the end, and Week 53 has all 7 slots unused.

In our data structure, we will initialize the grid with negative numbers for the unused days, and 0 for the rest:

[![Year 2005 Grid Initialized](/img/posts/3d-bar-charts/step-03-year-2005-grid-initialized.png)](/img/posts/3d-bar-charts/step-03-year-2005-grid-initialized.png)

### Using date-fns

To make our lives easier, we'll use the [date-fns](https://date-fns.org/) library to help us with the ISO 8601 calculations. We will use the [`getISOWeek`](https://date-fns.org/docs/getISOWeek) function to get the week number for a given date, and the [`getISOWeeksInYear`](https://date-fns.org/docs/getISOWeeksInYear) function to get the number of weeks in a given year. We can get the day index by using the [`getDay`](https://date-fns.org/docs/getDay) function and subtracting 1 from the result.

Let's try checking the ISO 8061 values for a few dates. We can create a function that will return an object with the values we need:

```ts
import {
  formatISO,
  getDay,
  getISODay,
  getISOWeek,
  getISOWeeksInYear,
  getISOWeekYear
} from 'date-fns';

const newDate = (year: number, month: number, day: number): Date => {
  // The month is 0-based, so January is 0 and December is 11.
  return new Date(year, month - 1, day, 0, 0, 0, 0);
};

const analyzeDate = (date: Date) => {
  return {
    // Extracts the YYYY-MM-DD portion of the Date object.
    formattedDate: formatISO(date, { representation: 'date' }),
    // The day of the week, 0-6, where Sunday is the first day of the week.
    gregDay: getDay(date),
    // The day of the week, 1-7, where Monday is the first day of the week.
    isoDay: getISODay(date),
    // The year of the date.
    gregYear: date.getFullYear(),
    // The ISO week-numbering year of the date.
    isoWeekYear: getISOWeekYear(date),
    // The ISO week-numbering week of the date.
    isoWeek: getISOWeek(date),
    // The number of weeks in the ISO week-numbering year.
    isoWeeksInYear: getISOWeeksInYear(date)
  };
};
```

Now, let's check the results for the dates `2004-12-28` to `2005-01-04`:

```ts
console.table([
  analyzeDate(newDate(2004, 12, 28)),
  analyzeDate(newDate(2004, 12, 29)),
  analyzeDate(newDate(2004, 12, 30)),
  analyzeDate(newDate(2004, 12, 31)),
  analyzeDate(newDate(2005, 1, 1)),
  analyzeDate(newDate(2005, 1, 2)),
  analyzeDate(newDate(2005, 1, 3)),
  analyzeDate(newDate(2005, 1, 4))
]);
```

| (index) | formattedDate | gregDay | isoDay | gregYear | isoWeekYear | isoWeek | isoWeeksInYear |
| ------- | ------------- | ------- | ------ | -------- | ----------- | ------- | -------------- |
| 0       | "2004-12-28"  | 2       | 2      | 2004     | 2004        | 53      | 53             |
| 1       | "2004-12-29"  | 3       | 3      | 2004     | 2004        | 53      | 53             |
| 2       | "2004-12-30"  | 4       | 4      | 2004     | 2004        | 53      | 53             |
| 3       | "2004-12-31"  | 5       | 5      | 2004     | 2004        | 53      | 53             |
| 4       | "2005-01-01"  | 6       | 6      | 2005     | 2004        | 53      | 53             |
| 5       | "2005-01-02"  | 0       | 7      | 2005     | 2004        | 53      | 53             |
| 6       | "2005-01-03"  | 1       | 1      | 2005     | 2005        | 1       | 52             |
| 7       | "2005-01-04"  | 2       | 2      | 2005     | 2005        | 1       | 52             |

> **NOTE**: Take note of the differences between the Gregorian and ISO 8601 years and weeks. Using the wrong functions can lead to [unwanted bugs in your application](https://www.youtube.com/watch?v=D3jxx8Yyw1c).

### Converting the ValuesPerDay mapping to our desired data structure

Let's now create a function that will convert our `ValuesPerDay` mapping to an array of `CalendarYearData` data. Create a `src/utils/calendar.ts` file and add the following code:

```ts filename=src/utils/calendar.ts
import { getISODay, getISOWeek, getISOWeeksInYear, getYear, parseISO } from 'date-fns';

import type { CalendarWeekData, CalendarYearData, CalendarYearsData, ValuesPerDay } from '~/types';

/** Creates a UTC date. */
export const createUtcDate = (year: number, month: number, day: number) =>
  new Date(Date.UTC(year, month - 1, day, 0, 0, 0, 0));

/**
 * Extracts the minimum and maximum years from the given `ValuesPerDay`
 * object.
 *
 * @param valuesPerDay - The `ValuesPerDay` object to extract the year
 * range from.
 * @returns An object containing the `minimumYear` and `maximumYear`.
 */
export const extractYearRange = (
  valuesPerDay: ValuesPerDay
): { minimumYear: number; maximumYear: number } => {
  let minimumYear = Infinity;
  let maximumYear = -Infinity;

  for (const dateString of valuesPerDay.keys()) {
    const year = getYear(parseISO(dateString));

    minimumYear = Math.min(minimumYear, year);
    maximumYear = Math.max(maximumYear, year);
  }

  return { minimumYear, maximumYear };
};

/**
 * Given a date, get its adjusted ISO week number based on the project
 * requirements:
 *
 * - If a date's month is January and its week number is greater than 50, it
 *   will be changed to week 0.
 * - If a date's month is December and its week number is less than 10, it
 *   will be changed to the number of ISO 8601 weeks in that year + 1.
 *
 * @param {Date} date - The date to get the adjusted ISO week number for.
 * @returns {number} - The adjusted ISO week number.
 */
export const getAdjustedISOWeek = (date: Date): number => {
  const month = date.getMonth();
  const isoWeek = getISOWeek(date);
  const isoWeeksInYear = getISOWeeksInYear(date);

  if (month === 0 && isoWeek > 50) {
    return 0;
  } else if (month === 11 && isoWeek < 10) {
    return isoWeeksInYear + 1;
  }

  return isoWeek;
};

/**
 * Initializes an empty `CalendarYearData`.
 *
 * If there are no values for that specific day, it will be `0`. If that day is
 * not part of the calendar year, it will be `-1`.
 *
 * @param {number} year - The year to initialize the data for.
 * @returns {CalendarYearData} a `CalendarYearData` with default values.
 */
export const initializeEmptyCalendarYearData = (year: number): CalendarYearData => {
  const firstDateOfYear = createUtcDate(year, 1, 1);
  const lastDateOfYear = createUtcDate(year, 12, 31);
  const firstWeekOfYearAdjusted = getAdjustedISOWeek(firstDateOfYear);
  const lastWeekOfYearAdjusted = getAdjustedISOWeek(lastDateOfYear);
  const firstDayOfYear = getISODay(firstDateOfYear) - 1;
  const lastDayOfYear = getISODay(lastDateOfYear) - 1;

  const yearData: CalendarYearData = [
    ...(Array.from(
      { length: 54 },
      (_, weekIndex) =>
        Array.from({ length: 7 }, (_, dayIndex) => {
          if (
            (weekIndex === firstWeekOfYearAdjusted && dayIndex < firstDayOfYear) ||
            (weekIndex === lastWeekOfYearAdjusted && dayIndex > lastDayOfYear)
          ) {
            return -1;
          } else if (weekIndex < firstWeekOfYearAdjusted || weekIndex > lastWeekOfYearAdjusted) {
            return -1;
          } else {
            return 0;
          }
        }) as CalendarWeekData
    ) as CalendarYearData)
  ];

  return yearData;
};

/**
 * Converts a `ValuesPerDay` object to a `CalendarYearsData` object.
 *
 * @param valuesPerDay - The `ValuesPerDay` object to convert.
 * @returns The converted `CalendarYearsData` object.
 */
export const convertToCalendarYearData = (valuesPerDay: ValuesPerDay): CalendarYearsData => {
  const { minimumYear, maximumYear } = extractYearRange(valuesPerDay);
  const yearsData: CalendarYearsData = [];

  for (let year = minimumYear; year <= maximumYear; year++) {
    yearsData.push(initializeEmptyCalendarYearData(year));
  }

  for (const [dateString, value] of valuesPerDay) {
    const date = parseISO(dateString);
    const year = getYear(date);

    const yearIndex = year - minimumYear;
    const weekIndex = getAdjustedISOWeek(date);
    const dayIndex = getISODay(date) - 1;

    const yearData = yearsData[yearIndex];
    if (!yearData) continue;

    const weekData = yearData[weekIndex];
    if (!weekData || weekData[dayIndex] === -1) continue;
    weekData[dayIndex] = (weekData[dayIndex] ?? 0) + value;
  }

  return yearsData;
};
```

Don't forget to export the functions in the `src/utils/index.ts` file:

```ts filename=src/utils/index.ts
// ...
export * from './calendar';
```

Here are the recap for each function:

- `createUtcDate`: This function creates a UTC date object given the year, month, and day as input. It takes the year, month, and day, and creates a new Date object with the specified values, ensuring the time components are set to 0 (midnight). By using [`Date.UTC`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/UTC), it ensures the date is represented in the UTC timezone.
- `extractYearRange`: This function takes a `ValuesPerDay` object as input and iterates through the date strings in the object to find the minimum and maximum years. It does this by first initializing the minimum year as `Infinity` and the maximum year as `-Infinity`. Then, for each date string, it parses the date and extracts the year, updating the minimum and maximum years accordingly.
- `getAdjustedISOWeek`: This function calculates an adjusted ISO week number for a given date based on the project's requirements. It first gets the month and the ISO week number of the input date. Then, it checks if the date falls under the specific conditions (i.e., January with a week number greater than 50, or December with a week number less than 10). If the date meets any of these conditions, it returns the adjusted week number. Otherwise, it returns the original week number.
- `initializeEmptyCalendarYearData`: This function initializes an empty `CalendarYearData` object for the given year. It first calculates the first and last dates of the year, along with their adjusted ISO week numbers and ISO day numbers (subtracting 1 to have a 0-based index). Then, it creates an array of 54 weeks (maximum possible weeks in a year), where each week is an array of 7 days. It fills the days with 0 if the day is part of the calendar year and -1 if the day is not part of the calendar year, using the calculated week and day numbers.
- `convertToCalendarYearData`: This function converts a `ValuesPerDay` object into an array of `CalendarYearData` values. It starts by extracting the minimum and maximum years from the input data using the `extractYearRange` function. Then, it initializes an empty `CalendarYearsData` object for each year in the range using the `initializeEmptyCalendarYearData` function. Next, it iterates through the input data, parsing the date strings, and calculating the year, week, and day indexes. It then adds the value to the appropriate day in the corresponding `CalendarYearData`.

## Step 4: Show the data in a 2D Grid

Now that we have the data in the correct format, we can use it to create a 2D grid per year to visualize the data.

Create a new file called `src/components/FlatGrids.tsx` and add the following code:

```tsx filename=src/components/FlatGrids.tsx
import type { FC } from 'react';

import type { CalendarWeekData, CalendarYearData, CalendarYearsData } from '~/types';

const DAYS = ['M', 'T', 'W', 'T', 'F', 'S', 'S'];

const YearTable: FC<{
  year: number;
  data: CalendarYearData;
}> = ({ year, data }) => {
  return (
    <table className="table-auto text-center">
      <caption className="text-xl">{year}</caption>
      <thead className="sticky top-0">
        <tr className="uppercase">
          <th></th>
          {DAYS.map((week, index) => {
            return (
              <th key={`week-${index}`} className="min-w-[50px] border bg-gray-600 text-gray-200">
                {week}
              </th>
            );
          })}
        </tr>
      </thead>
      <tbody>
        {data.map((week, index) => {
          return <WeekRow key={`week-${index}`} week={index} data={week} />;
        })}
      </tbody>
    </table>
  );
};

const WeekRow: FC<{ week: number; data: CalendarWeekData }> = ({ week, data }) => {
  return (
    <tr>
      <td className="px-3 py-1 text-sm">{week.toString().padStart(2, '0')}</td>
      {data.map((dayValue, index) => {
        return (
          <td
            key={`day-${index}`}
            className={`border px-2 py-1 ${dayValue < 0 ? 'bg-gray-200' : 'bg-white'}`}
          >
            {dayValue >= 0 && dayValue.toLocaleString('en-US')}
          </td>
        );
      })}
    </tr>
  );
};

const FlatGrids: FC<{
  data: CalendarYearsData;
  startYear: number;
}> = ({ data, startYear }) => {
  return (
    <div>
      {data.map((yearData, index) => {
        const year = startYear + index;
        return <YearTable key={`year-${year}`} year={year} data={yearData} />;
      })}
    </div>
  );
};

export default FlatGrids;
```

This just shows a simple table for each year, with the week numbers on the left, the days of the week on the top, and the word counts in the cells. If the cell has a negative value, it will only show a gray background.

Next, add the `FlatGrids` component to the Home Page:

```tsx filename=src/pages/index.tsx
import type { NextPage, GetServerSideProps } from 'next';
import Head from 'next/head';

import { parse as parseYaml } from 'yaml';

import { convertChaptersToMapping, convertToCalendarYearData } from '~/utils';
import type { Chapter, CalendarYearsData } from '~/types';
import FlatGrids from '~/components/FlatGrids';

const URL = `https://raw.githubusercontent.com/wandering-inndex/seed-data/main/data/media/twi-webnovel-chapters.yaml`;

interface HomeProps {
  /** The list of word counts per calendar year. */
  data: CalendarYearsData;
  /** The minimum year in the dataset. */
  minYear: number;
  /** The maximum year in the dataset. */
  maxYear: number;
  /** The minimum value in the dataset. */
  minValue: number;
  /** The maximum value in the dataset. */
  maxValue: number;
}

const Home: NextPage<HomeProps> = ({ data, minYear, maxYear, minValue, maxValue }) => {
  return (
    <>
      <Head>
        <title>Titan</title>
        <meta name="description" content="Visualize contribution charts in 3D" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className="h-screen w-screen p-1">
        <nav className="absolute left-1/2 z-10 mx-auto my-4 -translate-x-1/2 text-center text-4xl font-bold">
          Titan
        </nav>
        <ul>
          <li>Minimum Year: {minYear}</li>
          <li>Maximum Year: {maxYear}</li>
          <li>Minimum Value: {minValue.toLocaleString('en-US')}</li>
          <li>Maximum Value: {maxValue.toLocaleString('en-US')}</li>
        </ul>
        <FlatGrids data={data} startYear={minYear} />
      </main>
    </>
  );
};

export const getServerSideProps: GetServerSideProps<HomeProps> = async () => {
  const res = await fetch(URL);
  const text = await res.text();
  const chapters: Chapter[] = parseYaml(text) as Chapter[];

  const { mapping, minYear, maxYear, minValue, maxValue } = convertChaptersToMapping(chapters);
  const data = convertToCalendarYearData(mapping);

  return {
    props: {
      data,
      minYear,
      maxYear,
      minValue,
      maxValue
    }
  };
};

export default Home;
```

After saving, you can now see the values in a 2D grid:

![Show Tables Per Year](/img/posts/3d-bar-charts/step-04-show-year-array.png)

## Step 5: Show the Data in a 3D Grid

Now... let's make it 3D!

Create a new file called `src/components/TitanicGrids.tsx` and add the following code:

```tsx filename=src/components/TitanicGrids.tsx
import { type FC, useMemo } from 'react';
import { Canvas } from '@react-three/fiber';
import { OrbitControls, PerspectiveCamera, Box } from '@react-three/drei';

import type { CalendarYearsData, CalendarWeekData } from '~/types';

interface TitanicGridsProps {
  /** The list of number values per calendar year. */
  data: CalendarYearsData;
  /** The first year in the dataset. */
  startYear: number;
  /** The maximum value in the dataset. */
  maxValue: number;
}

/** Temporary interface for the light values. */
interface LightValues {
  /** The position of the light. */
  position: [number, number, number];
  /** The intensity of the light. */
  intensity: number;
  /** The color of the light. */
  color: string;
  /** Whether the light is enabled or not. */
  enable: boolean;
}

/** Shows a grid of 3D bar charts to represent the number values per year. */
const TitanicGrids: FC<TitanicGridsProps> = ({ data, startYear, maxValue }) => {
  // START: The temporary values for the grid.
  /** The size of each cell in the grid. */
  const cellSize = 1.0;
  /** The spacing between each cell in the grid. */
  const cellSpacing = 0.2;
  /** The spacing between each grid in the scene. */
  const gridSpacing = 1.2;
  /** The color of the cells. */
  const color = '#a0185a';
  /** The color of the unused cells. */
  const unusedColor = '#cccccc';
  /** The scale of the cells. */
  const scale = 20;
  /** The target of the camera. */
  const target: [number, number, number] = [30, 2, 32];
  /** Whether the camera should rotate or not. */
  const rotate = true;
  /** The speed of the camera rotation. */
  const speed = 1.0;
  /** The position of the camera. */
  const camera: [number, number, number] = [-49, 17, 30];
  /** The values for the first light. */
  const light1: LightValues = {
    position: [90, 0, 0],
    intensity: 0.8,
    color: '#ffffff',
    enable: true
  };
  /** The values for the second light. */
  const light2: LightValues = {
    position: [-180, 0, 0],
    intensity: 0.8,
    color: '#ffffff',
    enable: true
  };
  // END: The temporary values for the grid.

  /** The function to calculate the height of the cells. */
  const heightScale = useMemo(() => {
    return (value: number) => (value / maxValue) * scale;
  }, [maxValue, scale]);

  return (
    <>
      <Canvas>
        <OrbitControls target={target} autoRotate={rotate} autoRotateSpeed={speed} />
        <PerspectiveCamera makeDefault position={camera} />

        <hemisphereLight />
        {light1.enable && (
          <directionalLight
            position={light1.position}
            intensity={light1.intensity}
            color={light1.color}
          />
        )}
        {light2.enable && (
          <directionalLight
            position={light2.position}
            intensity={light2.intensity}
            color={light2.color}
          />
        )}

        {data.map((yearData, index) => {
          const gridPosition: [number, number, number] = [
            index * (gridSpacing * (cellSize + cellSpacing) * 7),
            0,
            0
          ];
          const yearValue = startYear + index;
          return (
            <group key={`grid-${yearValue}`} position={gridPosition}>
              {yearData.map((week: CalendarWeekData, weekIndex: number) => {
                return week.map((value: number, dayIndex: number) => {
                  const cellHeight = heightScale(value);
                  const cellPosition: [number, number, number] = [
                    (cellSize + cellSpacing) * dayIndex,
                    cellHeight / 2,
                    (cellSize + cellSpacing) * weekIndex
                  ];
                  return (
                    <Box
                      key={`grid-${yearValue}-cell-${weekIndex}-${dayIndex}`}
                      args={[cellSize, cellHeight, cellSize]}
                      position={cellPosition}
                    >
                      <meshPhongMaterial color={value < 0 ? unusedColor : color} />
                    </Box>
                  );
                });
              })}
            </group>
          );
        })}
      </Canvas>
    </>
  );
};

export default TitanicGrids;
```

This component is a bit more complex than the previous one.

A quick explanation on the imported components:

- It uses the `Canvas` component from `@react-three/fiber` to render the 3D scene.
- The `PerspectiveCamera` is a camera type that simulates the way humans perceive the world. It projects the 3D scene onto a 2D plane, creating a sense of depth by making objects appear smaller as they get farther away.
- The `OrbitControls` is a helper that allows the user to interact with the 3D scene using mouse or touch inputs. It enables panning, zooming, and orbiting the scene, providing an intuitive way to navigate the 3D space.
- The [`hemisphereLight`](https://threejs.org/docs/?q=directionalLight#api/en/lights/hemisphereLight) and [`directionalLight`](https://threejs.org/docs/?q=directionalLight#api/en/lights/DirectionalLight) are used to add some lights to the scene.
- The `Box` component is a convinient wrapper that used to render cuboid shapes.
- The [`meshPhongMaterial`](https://threejs.org/docs/#api/en/materials/MeshPhongMaterial) is a material that is used to render the surface of the 3D objects. It is a good choice for rendering objects with a shiny surface.

The calculations for the positions and dimensions are as follows:

- The `heightScale` function is used to calculate the height of the boxes based on its value, the maximum value in the dataset, and the scale factor. The height is calculated by dividing the cell value by the maximum value, then multiplying it by the scale factor. This ensures that the height of each cell is proportional to its value in relation to the `maxValue`.
- The `gridPosition` determines the position of each year's grid in the 3D space. The X-coordinate is calculated by multiplying the index of the year by the total width of the 7 columns of cells (including spacing between cells), and then by the `gridSpacing` value. This ensures that each year's grid is placed at a consistent distance from the previous grid along the X-axis.
- The `cellPosition` determines the position of each cell box within a year's grid. It is calculated based on the day and week indexes, `cellSize`, and `cellSpacing`. The X-coordinate is calculated by multiplying the day index by the sum of the `cellSize` and `cellSpacing`. The Y-coordinate is equal to half the cell height, ensuring that the base of each cell rests on the ground. The Z-coordinate is calculated by multiplying the week index by the sum of the `cellSize` and `cellSpacing`. This arrangement ensures that each cell is positioned correctly within the grid.

Now update the index page to use the new component:

```tsx filename=src/pages/index.tsx
import type { NextPage, GetServerSideProps } from 'next';
import Head from 'next/head';

import { parse as parseYaml } from 'yaml';

import { convertChaptersToMapping, convertToCalendarYearData } from '~/utils';
import type { Chapter, CalendarYearsData } from '~/types';
import TitanicGrids from '~/components/TitanicGrids';

const URL = `https://raw.githubusercontent.com/wandering-inndex/seed-data/main/data/media/twi-webnovel-chapters.yaml`;

interface HomeProps {
  /** The list of word counts per calendar year. */
  data: CalendarYearsData;
  /** The minimum year in the dataset. */
  minYear: number;
  /** The maximum value in the dataset. */
  maxValue: number;
}

const Home: NextPage<HomeProps> = ({ data, minYear, maxValue }) => {
  return (
    <>
      <Head>
        <title>Titan</title>
        <meta name="description" content="Visualize contribution charts in 3D" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <main className="h-screen w-screen p-1">
        <nav className="absolute left-1/2 z-10 mx-auto my-4 -translate-x-1/2 text-center text-4xl font-bold">
          Titan
        </nav>
        <TitanicGrids data={data} startYear={minYear} maxValue={maxValue} />
      </main>
    </>
  );
};

export const getServerSideProps: GetServerSideProps<HomeProps> = async () => {
  const res = await fetch(URL);
  const text = await res.text();
  const chapters: Chapter[] = parseYaml(text) as Chapter[];

  const { mapping, minYear, maxValue } = convertChaptersToMapping(chapters);
  const data = convertToCalendarYearData(mapping);

  return {
    props: {
      data,
      minYear,
      maxValue
    }
  };
};

export default Home;
```

If you run the app now, you should see something like this:

![Add 3D Chart](/img/posts/3d-bar-charts/step-05-add-3d-chart.png)

You can move the camera around by clicking and dragging the left mouse button, or by using touch inputs. You can also zoom in and out by scrolling the mouse wheel, or by pinching the screen. You can use the right mouse button or two finger drag to pan the camera.

## Step 6: Adding a helper GUI to customize the chart

We're almost done! There is one library we can add to make the chart easier to customize.

Open your `src/components/TitanicGrids.tsx` file and update it to look like this:

```tsx filename=src/components/TitanicGrids.tsx
import { type FC, useMemo } from 'react';
import { useControls, Leva } from 'leva';
import { Canvas } from '@react-three/fiber';
import { OrbitControls, PerspectiveCamera, Box } from '@react-three/drei';

import type { CalendarYearsData, CalendarWeekData } from '~/types';

interface TitanicGridsProps {
  /** The list of number values per calendar year. */
  data: CalendarYearsData;
  /** The first year in the dataset. */
  startYear: number;
  /** The maximum value in the dataset. */
  maxValue: number;
}

/** Shows a grid of 3D bar charts to represent the number values per year. */
const TitanicGrids: FC<TitanicGridsProps> = ({ data, startYear, maxValue }) => {
  const { cellSize, cellSpacing, gridSpacing, color, unusedColor, scale } = useControls('Cells', {
    /** The size of each cell in the grid. */
    cellSize: 1.0,
    /** The spacing between each cell in the grid. */
    cellSpacing: 0.2,
    /** The spacing between each grid in the scene. */
    gridSpacing: 1.2,
    /** The color of the cells. */
    color: '#a0185a',
    /** The color of the unused cells. */
    unusedColor: '#cccccc',
    /** The scale of the cells. */
    scale: {
      value: 20,
      min: 1
    }
  });

  const { target, rotate, speed, camera } = useControls('Controls', {
    /** The position of the camera. */
    camera: [-49, 17, 30],
    /** The target of the camera. */
    target: [30, 2, 32],
    /** Whether the camera should rotate or not. */
    rotate: true,
    /** The speed of the camera rotation. */
    speed: {
      value: 1.0,
      step: 0.1,
      min: 0
    }
  });

  /** The values for the first light. */
  const light1 = useControls('Light 1', {
    /** The position of the light. */
    position: {
      value: [90, 0, 0],
      step: 10
    },
    /** The intensity of the light. */
    intensity: {
      value: 0.8,
      step: 1.0
    },
    /** The color of the light. */
    color: '#ffffff',
    /** Whether the light is enabled or not. */
    enable: true
  });

  const light2 = useControls('Light 2', {
    /** The position of the light. */
    position: {
      value: [-180, 0, 0],
      step: 10
    },
    /** The intensity of the light. */
    intensity: {
      value: 0.8,
      step: 1.0
    },
    /** The color of the light. */
    color: '#ffffff',
    /** Whether the light is enabled or not. */
    enable: true
  });

  /** The function to calculate the height of the cells. */
  const heightScale = useMemo(() => {
    return (value: number) => (value / maxValue) * scale;
  }, [maxValue, scale]);

  return (
    <>
      <Leva collapsed />
      <Canvas>
        <OrbitControls target={target} autoRotate={rotate} autoRotateSpeed={speed} />
        <PerspectiveCamera makeDefault position={camera} />

        <hemisphereLight />
        {light1.enable && (
          <directionalLight
            position={light1.position}
            intensity={light1.intensity}
            color={light1.color}
          />
        )}
        {light2.enable && (
          <directionalLight
            position={light2.position}
            intensity={light2.intensity}
            color={light2.color}
          />
        )}

        {data.map((yearData, index) => {
          const gridPosition: [number, number, number] = [
            index * (gridSpacing * (cellSize + cellSpacing) * 7),
            0,
            0
          ];
          return (
            <group key={`grid-${startYear + index}`} position={gridPosition}>
              {yearData.map((week: CalendarWeekData, weekIndex: number) => {
                return week.map((value: number, dayIndex: number) => {
                  const cellHeight = heightScale(value);
                  const cellPosition: [number, number, number] = [
                    (cellSize + cellSpacing) * dayIndex,
                    cellHeight / 2,
                    (cellSize + cellSpacing) * weekIndex
                  ];
                  return (
                    <Box
                      key={`${weekIndex}-${dayIndex}`}
                      args={[cellSize, cellHeight, cellSize]}
                      position={cellPosition}
                    >
                      <meshPhongMaterial color={value < 0 ? unusedColor : color} />
                    </Box>
                  );
                });
              })}
            </group>
          );
        })}
      </Canvas>
    </>
  );
};

export default TitanicGrids;
```

We are using the `leva` library to add a panel to the right side of the screen. This floating panel will allow us to change the appearance of the grids in real time.

![Customize 3D Chart](/img/posts/3d-bar-charts/step-06-customize-3d-chart.png)

## Conclusion

In conclusion, we have successfully created a 3D grid visualization for time-series data using [React Three Fiber](https://github.com/pmndrs/react-three-fiber). To recap the steps we followed:

1. [Project Setup](#step-1-project-setup): We initialized a new React project using [Create T3 App](https://create.t3.gg/) and installed the necessary dependencies.
2. [Preparing our Data](#step-2-preparing-our-data): We fetched the raw dataset and transformed it into a format suitable for analysis.
3. [Creating the Time-series Data](#step-3-creating-the-time-series-data): We transformed the data again, this time organizing it by year and week. We also learned the basics of the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard and modified it to fit our needs.
4. [Show the data in a 2D Grid](#step-4-show-the-data-in-a-2d-grid): We started to visualize the data in a simple 2D grid format, understanding the structure of the data and preparing it for the next step.
5. [Show the Data in a 3D Grid](#step-5-show-the-data-in-a-3d-grid): We built upon our 2D grid and created a 3D grid representing the data points. This provided a more visually appealing representation of the time-series data.
6. [Adding a helper GUI to customize the chart](#step-6-adding-a-helper-gui-to-customize-the-chart): We used the [`leva` library](https://github.com/pmndrs/leva) to add a helper interface for customizing the appearance and behavior of the grid elements in real-time.

This tutorial is just the beginning of what you can do with React Three Fiber. Potential improvements could include:

- Adding tooltips and labels to display more information about each bar on hover.
- Adding animations to the bars for a more dynamic user experience.
- Integrating filters and controls for users to modify the data displayed in real-time.

I encourage you to experiment with the code and build upon it to create your own unique 3D grid visualizations. With the foundation laid out in this tutorial, you can now explore the possibilities of React Three Fiber and create even more complex and engaging 3D visualizations.

Happy coding!
